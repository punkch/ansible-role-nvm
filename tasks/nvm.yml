---

# testing for who is running the playbook to be able to intelligently associate
# a user when installing in a protected sirecotry like /opt/nvm.
# WARNING!! This only makes it available to that specific user and not people associated
# with a group see https://github.com/morgangraphics/ansible-role-nvm/issues/26
- name: "Who is running this playbook?"
  command: whoami
  register: nvm_whoami
  changed_when: false

- name: Set a fact with the user name running the playbook.
  set_fact:
    login_user: "{{ nvm_whoami.stdout }}"

- name: Set full nvm_profile path | Default
  set_fact:
    nvm_profile: "$HOME/.bashrc"
  when: nvm_profile == '.bashrc'

- name: Set full nvm_profile path | Custom Path
  set_fact:
    nvm_profile: "{{ nvm_profile }}"
  when: nvm_profile != '.bashrc'

# ERROR HANDLING
- name: test to ensure symbiotic variables are declared | nvm_dir AND nvm_profile
  fail:
    msg: "If setting a custom nvm_dir directory e.g. /opt/nvm, nvm_dir MUST be used in combination with nvm_profile"
  when: nvm_dir and nvm_profile == '.bashrc' and nvm_install != 'git'

- name: test to ensure symbiotic variables are declared | nvm_dir AND nvm_install = git
  fail:
    msg: "If installing via GIT nvm_install: git MUST be used in combination with nvm_dir and include the full path e.g. nvm_dir: '$HOME/.nvm'"
  when: not nvm_dir and nvm_install == 'git'

# ENVIRONMENT SHELL TESTING

# https://github.com/morgangraphics/ansible-role-nvm/issues/18
- name: determine shell in which we are running
  block:

    - name: set default found path
      set_fact:
        found_path: ''

    - name: test for shells
      command: "which {{ item }}"
      with_items:
        - bash
        - dash
        - zsh
        - csh
        - tcsh
      register: nvm_shell_path
      when: item in nvm_profile
      changed_when: nvm_shell_path is undefined

    - name: set found path
      set_fact:
        found_path: "{{ nvm_shell_path.results | selectattr('stdout', 'defined') | map(attribute = 'stdout') | list | first }}"
      when: nvm_shell_path.results | selectattr('stdout', 'defined') | map(attribute = 'stdout') | list | length > 0

    - name: set bash command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'bash' }
      when: '"bash" in nvm_profile'

    - name: set zsh command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'zsh' }
      when: '"zsh" in nvm_profile'

    - name: set csh command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'csh' }
      when: "'csh' in nvm_profile and 'tcsh' not in nvm_profile"

    - name: set tcsh command
      set_fact:
        user_shell: { 'executable': '{{ found_path }}', 'flags': '-ic', 'alias': 'tcsh' }
      when: "'tcsh' in nvm_profile"

    - name: "!WARNING! set unrecommended default for any other nvm_profile value !WARNING!"
      set_fact:
        user_shell: { 'executable': '/etc/bash', 'flags': '-ic', 'alias': 'bash' }
      when: (nvm_shell_path is undefined) or (found_path | bool)

    - name: does profile file exist | Default
      stat:
        path: "{{ nvm_profile }}"
      register: nvm_profile_file_test

    - name: register profile_file_teast result | Default path
      set_fact:
        nvm_profile_file: "{{ nvm_profile_file_test.stat }}"

    - name: Create profile file if it does not exist
      file:
        mode: 0777
        path: "{{ nvm_profile }}"
        state: touch
      when: not nvm_profile_file.exists
      become: true

  when: nvm_profile | length != 0

#CLEAN INSTALL OF NVM
- name: uninstall nvm
  import_tasks: uninstall.yml
  when: clean_install

# WGET (DEAULT) OR CURL
- name: Installing via curl or wget
  block:

  - name: Check if wget or curl is installed
    command: "which {{ nvm_install }}"
    register: nvm_cmd
    changed_when: "nvm_cmd.rc != 0"

  - name: Determine if install type wget
    set_fact:
      run_command: 'wget -qO-'
    when: "'/wget' in nvm_cmd.stdout"

  - name: Determine if install type curl
    set_fact:
      run_command: 'curl -o-'
    when: "'/curl' in nvm_cmd.stdout"

  # TODO: https://github.com/morgangraphics/ansible-role-nvm/issues/26
  - name: Create custom nvm_dir if it does not exist
    file:
      mode: 0775
      path: "{{ nvm_dir }}"
      state: directory
      owner: "{{ login_user }}"
    become: true
    become_user: root
    when: nvm_dir | length != 0

  # There are some potential security concerns with piping the install.sh script to whatever shell alias is defined: Risk is Low but not absolute
  # https://blog.dijit.sh//don-t-pipe-curl-to-bash
  # https://news.ycombinator.com/item?id=12766049
  # https://sandstorm.io/news/2015-09-24-is-curl-bash-insecure-pgp-verified-install
  - name: Install NVM
    shell: >
      set -e pipefail
      && {{ run_command }} https://raw.githubusercontent.com/nvm-sh/nvm/v{{ nvm_version }}/install.sh |
      NVM_SOURCE={{ nvm_source }} NVM_DIR={{ nvm_dir }} PROFILE={{ nvm_profile }} {{ user_shell.alias }}
    args:
      warn: false
      executable: "{{ user_shell.executable }}"
    register: nvm_install_result
    changed_when:
      - "'already installed' not in nvm_install_result.stdout"
    failed_when:
      - "'Permission denied' in nvm_install_result.stderr"
      - "'not found' in nvm_install_result.stderr"
      - "'No such file or directory' in nvm_install_result.stderr"

  when: nvm_install in ['curl', 'wget']


# GIT
# Running the install.sh script will clone the repo anyway
# While the NVM documentation says you should always run install.sh there is
# GIT specific doumentation shows it working as a clone, and additon to
# the profile and then sourcing the .nvm.sh script. We don't need that here
- name: install via git
  block:

    - name: Check if git is installed
      command: "which {{ nvm_install }}"
      register: nvm_cmd
      changed_when: "nvm_cmd.rc != 0"

    - name: Clone NVM Git Repo
      git:
        dest: "{{ nvm_dir }}"
        repo: 'https://github.com/nvm-sh/nvm.git'
        version: "v{{ nvm_version }}"
      when: "'/git' in nvm_cmd.stdout"

    - name: Add NVM to nvm_profile
      blockinfile:
        block: |
          export NVM_DIR="{{ nvm_dir }}"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" # This loads nvm
        create: yes
        marker_begin: "Installed nvm via {{ role_repo }} START"
        marker_end: "{{ role_repo }} END"
        mode: 0644
        path: "{{ nvm_profile }}"
        state: present

  when: "nvm_install == 'git'"


- name: Update profile permissions to lock it down after writing
  file:
    mode: 0644
    path: "$HOME/{{ nvm_profile }}"
  become: true
  become_user: root
  when: not nvm_profile_file.exists


- name: Check NVM Version | Default # noqa 305
  shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"nvm --version\"' }}"
  register: nvm_version_response
  changed_when: nvm_version_response.rc != 0


# NVM CONFIGURATION

- name: LTS Check
  set_fact:
    nodejs_version: --lts
  when: "nodejs_version == 'lts'"

# This scenario handles the first run/install of NVM because this will automatically
# alias the specified version as default - This should handle most use cases
- name: Install Node # noqa 305
  shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"nvm install ' +  nodejs_version + '\"' }}"
  register: nvm_node_version_response
  changed_when: "'already installed' not in nvm_node_version_response.stderr"

# In the event there are multiple versions of Node being installed/used/upgraded
# on the same machine we'll need to alias the default version accordingly
- name: Set default version of Node if multiple versions exist # noqa 305
  shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"nvm alias default ' +  nodejs_version + '\"' }}"
  when:  default

- name: Run whatever nvm_commands are there # noqa 305
  shell: "{{ user_shell.executable + ' ' + user_shell.flags + ' \"' +  item + '\"' }}"
  register: nvm_commands_response
  with_items:
    "{{ nvm_commands }}"
  when: nvm_commands | length > 0

# REMOVE AUTOCOMPLETE

- name: Searching for autocomplete string in the file
  lineinfile:
    path: "{{ nvm_profile }}"
    regexp: "\\$NVM_DIR/bash_completion"
    state: absent
  check_mode: yes
  changed_when: false
  register: nvm_autocomplete_response

- name: Remove NVM autocomplete in nvm_profile
  lineinfile:
    path: "{{ nvm_profile }}"
    regexp: "\\$NVM_DIR/bash_completion"
    state: absent
  changed_when: "'nvm source string already' not in nvm_install_result.stdout
    and 'Appending bash_completion source' in nvm_install_result.stdout"
  when: (not autocomplete | bool) and (nvm_autocomplete_response.found > 0)

#UNINSTALL

- name: uninstall nvm
  import_tasks: uninstall.yml
  when: uninstall
